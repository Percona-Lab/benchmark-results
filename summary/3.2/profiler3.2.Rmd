---

title: "Percona Server for MongoDB: Profiler impact on OLTP workloads"
author: "Percona Lab"
generated on:`r format(Sys.Date(), "%B %d, %Y")`
output:
  md_document:
    variant: markdown_github

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(reshape2)
library(knitr)
library(plyr)

## the next functions copied from ggthemes, with just a minor change to 
## extended_range_breaks_

# Much of this code is copied from the labeling package.
.simplicity <- function(q, Q, j, lmin, lmax, lstep) {
  eps <- .Machine$double.eps * 100

  n <- length(Q)
  i <- match(q, Q)[1]
  v <- ifelse( (lmin %% lstep < eps ||
                 lstep - (lmin %% lstep) < eps) &&
                lmin <= 0 && lmax >= 0, 1, 0)
  1 - (i - 1) / (n - 1) - j + v
}

.simplicity.max <- function(q, Q, j) {
  n <- length(Q)
  i <- match(q, Q)[1]
  v <- 1

  1 - (i - 1) / (n - 1) - j + v
}

.coverage <- function(dmin, dmax, lmin, lmax) {
  range <- dmax - dmin
  1 - 0.5 * ( (dmax - lmax) ^ 2 + (dmin - lmin) ^ 2) / ( (0.1 * range) ^ 2)
}

.coverage.max <- function(dmin, dmax, span) {
  range <- dmax - dmin
  if (span > range) {
    half <- (span - range) / 2
    1 - 0.5 * (half ^ 2 + half ^ 2) / ( (0.1 * range) ^ 2)
  }
  else {
    1
  }
}

.density <- function(k, m, dmin, dmax, lmin, lmax) {
  r <- (k - 1) / (lmax - lmin)
  rt <- (m - 1) / (max(lmax, dmax) - min(dmin, lmin))
  2 - max( r / rt, rt / r )
}

.density.max <- function(k, m) {
  if (k >= m)
    2 - (k - 1) / (m - 1)
  else
    1
}

.legibility <- function(lmin, lmax, lstep) {
  1      ## did all the legibility tests in C#, not in R.
}

# from scales package
zero_range <- function(x, tol = 1000 * .Machine$double.eps) {
  if (length(x) == 1)
    return(TRUE)
  if (length(x) != 2)
    stop("x must be length 1 or 2")
  if (any(is.na(x)))
    return(NA)
  if (x[1] == x[2])
    return(TRUE)
  if (all(is.infinite(x)))
    return(FALSE)
  m <- min(abs(x))
  if (m == 0)
    return(FALSE)
  abs( (x[1] - x[2]) / m) < tol
}

# from scales package
precision <- function(x) {
  rng <- range(x, na.rm = TRUE)
  span <- if (zero_range(rng))
    abs(rng[1])
  else diff(rng)
  10 ^ floor(log10(span))
}

smart_digits <- function(x, ...) {
  if (length(x) == 0)
    return(character())
  accuracy <- precision(x)
  x <- round(x / accuracy) * accuracy
  format(x, ...)
}

smart_digits_format <- function(x, ...) {
    function(x) smart_digits(x, ...)
}

extended_range_breaks_ <- function(dmin, dmax, n = 5,
                                   Q = c(1, 5, 2, 2.5, 4, 3),
                                   w = c(0.25, 0.2, 0.5, 0.05)) {
  eps <- .Machine$double.eps * 100

  if (dmin > dmax) {
    temp <- dmin
    dmin <- dmax
    dmax <- temp
  }

  if (dmax - dmin < eps) {
    #if the range is near the floating point limit,
    #let seq generate some equally spaced steps.
    return(seq(from = dmin, to = dmax, length.out = n))
  }

  n <- length(Q)

  best <- list()
  best$score <- -2

  j <- 1
  while (j < Inf) {
    for (q in Q) {
      sm <- .simplicity.max(q, Q, j)

      if ( (w[1] * sm + w[2] + w[3] + w[4]) < best$score) {
        j <- Inf
        break
      }

      k <- 2
      while (k < Inf) {
        dm <- .density.max(k, n)
        if ( (w[1] * sm + w[2] + w[3] * dm + w[4]) < best$score)
          break

        delta <- (dmax - dmin) / (k + 1) / j / q
        z <- ceiling(log(delta, base = 10))

        while (z < Inf) {
          step <- j * q * 10 ^ z

          cm <- .coverage.max(dmin, dmax, step * (k - 1))

          if ( (w[1] * sm + w[2] * cm + w[3] * dm + w[4]) < best$score)
            break

          min_start <- floor(dmax / (step)) * j - (k - 1) * j
          max_start <- ceiling(dmin / (step)) * j

          if (min_start > max_start) {
            z <- z + 1
            next
          }

          for (start in min_start:max_start) {
            lmin <- start * (step / j)
            lmax <- lmin + step * (k - 1)
            lstep <- step

            s <- .simplicity(q, Q, j, lmin, lmax, lstep)
            c <- .coverage(dmin, dmax, lmin, lmax)
            g <- .density(k, n, dmin, dmax, lmin, lmax)
            l <- .legibility(lmin, lmax, lstep)

            score <- w[1] * s + w[2] * c + w[3] * g + w[4] * l

            if (score > best$score
               && lmin >= dmin
               && lmax <= dmax) {
                best <- list(lmin = lmin,
                             lmax = lmax,
                             lstep = lstep,
                             score = score)
            }
          }
          z <- z + 1
        }
        k <- k + 1
      }
    }
    j <- j + 1
  }
  breaks <- seq(from = best$lmin, to = best$lmax, by = best$lstep)
  if (length(breaks) >= 2) {
      breaks[1] <- dmin
      breaks[length(breaks)] <- dmax
  }
  rbind(0,breaks)
}

#' @rdname range_breaks
#' @param ... other arguments passed to \code{extended_range_breaks_}
#' @return A function which returns breaks given a vector.
#' @export
extended_range_breaks <- function(n = 5, ...)  {
    function(x) {
        extended_range_breaks_(min(x), max(x), n, ...)
    }
}

## end of functions copied from ggthemes

## the next functions copied from ggthemes, with just a minor change to 
## extended_range_breaks_

# Much of this code is copied from the labeling package.
.simplicity <- function(q, Q, j, lmin, lmax, lstep) {
  eps <- .Machine$double.eps * 100

  n <- length(Q)
  i <- match(q, Q)[1]
  v <- ifelse( (lmin %% lstep < eps ||
                 lstep - (lmin %% lstep) < eps) &&
                lmin <= 0 && lmax >= 0, 1, 0)
  1 - (i - 1) / (n - 1) - j + v
}

.simplicity.max <- function(q, Q, j) {
  n <- length(Q)
  i <- match(q, Q)[1]
  v <- 1

  1 - (i - 1) / (n - 1) - j + v
}

.coverage <- function(dmin, dmax, lmin, lmax) {
  range <- dmax - dmin
  1 - 0.5 * ( (dmax - lmax) ^ 2 + (dmin - lmin) ^ 2) / ( (0.1 * range) ^ 2)
}

.coverage.max <- function(dmin, dmax, span) {
  range <- dmax - dmin
  if (span > range) {
    half <- (span - range) / 2
    1 - 0.5 * (half ^ 2 + half ^ 2) / ( (0.1 * range) ^ 2)
  }
  else {
    1
  }
}

.density <- function(k, m, dmin, dmax, lmin, lmax) {
  r <- (k - 1) / (lmax - lmin)
  rt <- (m - 1) / (max(lmax, dmax) - min(dmin, lmin))
  2 - max( r / rt, rt / r )
}

.density.max <- function(k, m) {
  if (k >= m)
    2 - (k - 1) / (m - 1)
  else
    1
}

.legibility <- function(lmin, lmax, lstep) {
  1      ## did all the legibility tests in C#, not in R.
}

# from scales package
zero_range <- function(x, tol = 1000 * .Machine$double.eps) {
  if (length(x) == 1)
    return(TRUE)
  if (length(x) != 2)
    stop("x must be length 1 or 2")
  if (any(is.na(x)))
    return(NA)
  if (x[1] == x[2])
    return(TRUE)
  if (all(is.infinite(x)))
    return(FALSE)
  m <- min(abs(x))
  if (m == 0)
    return(FALSE)
  abs( (x[1] - x[2]) / m) < tol
}

# from scales package
precision <- function(x) {
  rng <- range(x, na.rm = TRUE)
  span <- if (zero_range(rng))
    abs(rng[1])
  else diff(rng)
  10 ^ floor(log10(span))
}

smart_digits <- function(x, ...) {
  if (length(x) == 0)
    return(character())
  accuracy <- precision(x)
  x <- round(x / accuracy) * accuracy
  format(x, ...)
}

smart_digits_format <- function(x, ...) {
    function(x) smart_digits(x, ...)
}

extended_range_breaks_ <- function(dmin, dmax, n = 5,
                                   Q = c(1, 5, 2, 2.5, 4, 3),
                                   w = c(0.25, 0.2, 0.5, 0.05)) {
  eps <- .Machine$double.eps * 100

  if (dmin > dmax) {
    temp <- dmin
    dmin <- dmax
    dmax <- temp
  }

  if (dmax - dmin < eps) {
    #if the range is near the floating point limit,
    #let seq generate some equally spaced steps.
    return(seq(from = dmin, to = dmax, length.out = n))
  }

  n <- length(Q)

  best <- list()
  best$score <- -2

  j <- 1
  while (j < Inf) {
    for (q in Q) {
      sm <- .simplicity.max(q, Q, j)

      if ( (w[1] * sm + w[2] + w[3] + w[4]) < best$score) {
        j <- Inf
        break
      }

      k <- 2
      while (k < Inf) {
        dm <- .density.max(k, n)
        if ( (w[1] * sm + w[2] + w[3] * dm + w[4]) < best$score)
          break

        delta <- (dmax - dmin) / (k + 1) / j / q
        z <- ceiling(log(delta, base = 10))

        while (z < Inf) {
          step <- j * q * 10 ^ z

          cm <- .coverage.max(dmin, dmax, step * (k - 1))

          if ( (w[1] * sm + w[2] * cm + w[3] * dm + w[4]) < best$score)
            break

          min_start <- floor(dmax / (step)) * j - (k - 1) * j
          max_start <- ceiling(dmin / (step)) * j

          if (min_start > max_start) {
            z <- z + 1
            next
          }

          for (start in min_start:max_start) {
            lmin <- start * (step / j)
            lmax <- lmin + step * (k - 1)
            lstep <- step

            s <- .simplicity(q, Q, j, lmin, lmax, lstep)
            c <- .coverage(dmin, dmax, lmin, lmax)
            g <- .density(k, n, dmin, dmax, lmin, lmax)
            l <- .legibility(lmin, lmax, lstep)

            score <- w[1] * s + w[2] * c + w[3] * g + w[4] * l

            if (score > best$score
               && lmin >= dmin
               && lmax <= dmax) {
                best <- list(lmin = lmin,
                             lmax = lmax,
                             lstep = lstep,
                             score = score)
            }
          }
          z <- z + 1
        }
        k <- k + 1
      }
    }
    j <- j + 1
  }
  breaks <- seq(from = best$lmin, to = best$lmax, by = best$lstep)
  if (length(breaks) >= 2) {
      breaks[1] <- dmin
      breaks[length(breaks)] <- dmax
  }
  rbind(0,breaks)
}

#' @rdname range_breaks
#' @param ... other arguments passed to \code{extended_range_breaks_}
#' @return A function which returns breaks given a vector.
#' @export
extended_range_breaks <- function(n = 5, ...)  {
    function(x) {
        extended_range_breaks_(min(x), max(x), n, ...)
    }
}

## end of functions copied from ggthemes

data <- read.csv("../../alldata3.2.csv", header=T)
data0 = subset(data, user_provided_threads <= 16)
data1 = subset(data, user_provided_threads > 16)

nothreads <- c(1,4,8,16,32,64,256)

```
# Percona Server for MongoDB 3.2.0-1.0 - Profiler impact 

## Setup

* Client (sysbench) and server are on the same machine
* CPU: 48 logical CPU threads servers Intel(R) Xeon(R) CPU E5-2680 v3 @ 2.50GHz
* 128GB RAM (64GB storage engine cache)
* sysbench with mongodb support, 16 collections x 2M documents (~6GB compressed), uniform distribution. 
* Profiler disabled (--profile=0) or enabled for all queries (--profile=2), represented respectively as pl0 and pl2 on the graphs
* WiredTiger storage engine

## Throughput by workload and profiler setting 

```{r perthreads, fig.width=16, warning=FALSE, echo=FALSE}
for (t in nothreads) {
  subdata <- subset(data, threads == t)
  msg_threads = "Threads"
  if (t==1) {
    msg_threads="Thread"
  }
  gtitle <- paste("Percona Server for MongoDB / profiler impact on throughput,", t,msg_threads)
  print(ggplot(subdata, aes(x=ts, y=tps, colour=as.factor(workload))) + geom_jitter() + scale_colour_discrete(name = "") + facet_grid(. ~ profile_level, labeller = label_value) + xlab("Time in seconds (10 sec interval)") + ylab("Throughput (read/write ops per second)") + ggtitle(gtitle) + scale_y_continuous(breaks = extended_range_breaks()(subdata$tps))+ expand_limits(x=0, y=0) + theme_bw() + theme(panel.grid = element_line(colour="#010101",size=1), panel.background = element_rect(colour="#000000"), plot.background = element_rect(colour="#000000"), strip.background = element_rect(colour="#010101"), text=element_text(size=20), strip.text=element_text(size=24)))
}
```


